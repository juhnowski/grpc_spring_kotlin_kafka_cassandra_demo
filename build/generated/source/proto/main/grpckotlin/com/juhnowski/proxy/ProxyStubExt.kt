package com.juhnowski.proxy

import io.rouz.grpc.*
import com.juhnowski.proxy.ProxyGrpc.ProxyStub

import kotlinx.coroutines.channels.ReceiveChannel
import kotlin.coroutines.suspendCoroutine

/**
 * Kotlin extension functions for [com.juhnowski.proxy.ProxyGrpc.ProxyStub]
 *
 * Generated by gRPC Kotlin generator
 * Source: greeting.proto
 */




inline suspend fun ProxyStub.proxy(request: com.juhnowski.proxy.MsgRequest): com.juhnowski.proxy.MsgReply {
    return suspendCoroutine {
        proxy(request, ContinuationStreamObserver(it))
    }
}



fun ProxyStub.msgServerStream(request: com.juhnowski.proxy.MsgRequest): ReceiveChannel<com.juhnowski.proxy.MsgReply> {
    val responseChannel = StreamObserverChannel<com.juhnowski.proxy.MsgReply>()
    msgServerStream(request, responseChannel)
    return responseChannel
}



fun ProxyStub.msgClientStream(): ManyToOneCall<com.juhnowski.proxy.MsgRequest, com.juhnowski.proxy.MsgReply> {
    val responseDeferred = StreamObserverDeferred<com.juhnowski.proxy.MsgReply>()
    val requestObserver = msgClientStream(responseDeferred)
    return ManyToOneCall(requestObserver, responseDeferred)
}



fun ProxyStub.msgBidirectional(): ManyToManyCall<com.juhnowski.proxy.MsgRequest, com.juhnowski.proxy.MsgReply> {
    val responseChannel = StreamObserverChannel<com.juhnowski.proxy.MsgReply>()
    val requestObserver = msgBidirectional(responseChannel)
    return ManyToManyCall(requestObserver, responseChannel)
}
